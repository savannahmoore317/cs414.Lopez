1.
AI used
GeekforGeeks used
#include <iostream>
#include <vector>
#include <algorithm>
#include <chrono>
#include <functional>

class SortStrategy {
public:
    virtual void sort(std::vector<int>& data) = 0;
    virtual ~SortStrategy() {}
};

class QuickSort : public SortStrategy {
    void quick_sort(std::vector<int>& data, int low, int high) {
        if (low < high) {
            int pivot = data[high];
            int i = low - 1;
            for (int j = low; j < high; ++j) {
                if (data[j] <= pivot) {
                    ++i;
                    std::swap(data[i], data[j]);
                }
            }
            std::swap(data[i + 1], data[high]);
            int pi = i + 1;
            quick_sort(data, low, pi - 1);
            quick_sort(data, pi + 1, high);
        }
    }
public:
    void sort(std::vector<int>& data) override {
        if (!data.empty()) quick_sort(data, 0, data.size() - 1);
    }
};

class MergeSort : public SortStrategy {
    void merge(std::vector<int>& data, int left, int mid, int right) {
        int n1 = mid - left + 1;
        int n2 = right - mid;
        std::vector<int> L(n1), R(n2);
        for (int i = 0; i < n1; ++i) L[i] = data[left + i];
        for (int j = 0; j < n2; ++j) R[j] = data[mid + 1 + j];
        int i = 0, j = 0, k = left;
        while (i < n1 && j < n2) {
            if (L[i] <= R[j]) data[k++] = L[i++];
            else data[k++] = R[j++];
        }
        while (i < n1) data[k++] = L[i++];
        while (j < n2) data[k++] = R[j++];
    }
    void merge_sort(std::vector<int>& data, int left, int right) {
        if (left < right) {
            int mid = left + (right - left) / 2;
            merge_sort(data, left, mid);
            merge_sort(data, mid + 1, right);
            merge(data, left, mid, right);
        }
    }
public:
    void sort(std::vector<int>& data) override {
        if (!data.empty()) merge_sort(data, 0, data.size() - 1);
    }
};

class BubbleSort : public SortStrategy {
public:
    void sort(std::vector<int>& data) override {
        int n = data.size();
        for (int i = 0; i < n - 1; ++i) {
            for (int j = 0; j < n - i - 1; ++j) {
                if (data[j] > data[j + 1]) std::swap(data[j], data[j + 1]);
            }
        }
    }
};

class SortContext {
    SortStrategy* strategy = nullptr;
public:
    void set_strategy(SortStrategy* s) { strategy = s; }
    void execute_strategy(std::vector<int>& data) {
        if (strategy) strategy->sort(data);
    }
};

int main(int argc, char* argv[]) {
    SortContext context;
    QuickSort quick;
    MergeSort merge;
    BubbleSort bubble;
    std::vector<int> data = {5, 2, 9, 1, 5, 6};

    std::string algo = argc > 1 ? argv[1] : "quick";

    if (algo == "quick") context.set_strategy(&quick);
    else if (algo == "merge") context.set_strategy(&merge);
    else context.set_strategy(&bubble);

    auto start = std::chrono::high_resolution_clock::now();
    context.execute_strategy(data);
    auto end = std::chrono::high_resolution_clock::now();

    for (int n : data) std::cout << n << " ";
    std::cout << "\nTime: "
              << std::chrono::duration_cast<std::chrono::microseconds>(end - start).count()
              << " microseconds\n";
}

