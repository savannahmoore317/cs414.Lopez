AI used
geekforgeeks used

module type MONAD = sig
  type 'a t
  val return : 'a -> 'a t
  val bind   : 'a t -> ('a -> 'b t) -> 'b t
  val map    : ('a -> 'b) -> 'a t -> 'b t
end

module Make_infix (M : MONAD) = struct
  let ( >>= ) = M.bind
  let ( let* ) = M.bind
  let ( >|= ) m f = M.map f m
end

module OptionM : MONAD = struct
  type 'a t = 'a option
  let return x = Some x
  let bind m f = match m with None -> None | Some x -> f x
  let map f m = match m with None -> None | Some x -> Some (f x)
end
module O = Make_infix(OptionM)

module ResultM : MONAD = struct
  type 'a t = ('a, string) result
  let return x = Ok x
  let bind m f = match m with Error e -> Error e | Ok x -> f x
  let map f m = match m with Error e -> Error e | Ok x -> Ok (f x)
end
module R = Make_infix(ResultM)

module ListM : MONAD = struct
  type 'a t = 'a list
  let return x = [x]
  let bind xs f = List.concat (List.map f xs)
  let map f xs = List.map f xs
end
module L = Make_infix(ListM)

3.let safe_div (a : int) (b : int) : int option =
  if b = 0 then None else Some (a / b)

let safe_div_three (x : int) (y : int) (z : int) : int option =
  let open Option in
  safe_div x y >>= fun a ->
  safe_div a z
